<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pokémon Chess — รุ่นเสถียร</title>
<style>
  :root{
    --bg:#0e1220;
    --panel:#151a2e;
    --accent:#7fb3ff;
    --accent2:#ffd166;
    --good:#51e3a2;
    --bad:#ff6b6b;
    --muted:#9aa4bf;
    --square-a:#2a2f4a;
    --square-b:#20243b;
    --hilite:#36406b;
    --move:#3b6fb6;
    --capture:#b63b59;
  }
  *{box-sizing:border-box}
  body{
    margin:0; background:var(--bg); color:#e8eeff;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans Thai", "Noto Sans", "Helvetica Neue", Arial;
  }
  header{
    padding:14px 18px; display:flex; gap:12px; align-items:center; justify-content:space-between;
    border-bottom:1px solid #1f2450;
    background: linear-gradient(180deg, #14193a, #121630 60%);
  }
  header h1{ margin:0; font-size:18px; letter-spacing:.2px }
  .wrap{
    display:grid; grid-template-columns:minmax(320px, 780px) 360px;
    gap:16px; padding:16px;
  }
  @media (max-width: 980px){ .wrap{ grid-template-columns:1fr } }
  .board{
    width:100%;
    max-width:min(92vmin, 760px);
    margin:auto;
    aspect-ratio:1/1; border-radius:16px; overflow:hidden;
    background:#171a2b; position:relative;
    box-shadow: 0 8px 24px rgba(0,0,0,.35), inset 0 0 0 1px #232956;
  }
  .grid{ position:absolute; inset:10px; display:grid;
         grid-template-columns:repeat(8,1fr); grid-template-rows:repeat(8,1fr); gap:2px; }
  .sq{
    border-radius:10px; position:relative; cursor:pointer; user-select:none;
    display:flex; align-items:center; justify-content:center; transition: background .12s ease;
  }
  .sq.a{ background:var(--square-a) }
  .sq.b{ background:var(--square-b) }
  .sq.sel{ outline:2px solid var(--move) }
  .sq.mv::after{
    content:''; width:16%; padding-bottom:16%; border-radius:50%; position:absolute;
    background:var(--move); opacity:.9; box-shadow:0 0 0 4px rgba(59,111,182,.28);
  }
  .sq.cap::after{
    content:''; position:absolute; inset:12%; border:3px dashed var(--capture); border-radius:10px;
  }
  .piece{
    width:92%; height:92%; display:grid; place-items:center; padding:4px;
  }
  .piece-img{
    width:100%; height:100%; display:block; object-fit:contain; border-radius:14px;
    box-shadow: inset 0 6px 16px rgba(0,0,0,.35), 0 8px 18px rgba(0,0,0,.35);
    border:3px solid transparent;
  }
  .w .piece-img{ border-color:#fff; box-shadow:inset 0 6px 18px rgba(255,255,255,.05), 0 8px 18px rgba(0,0,0,.45) }
  .badge{
    position:absolute; top:6px; left:6px;
    background:var(--accent2); color:#211; font-size:10px; padding:2px 6px; border-radius:999px; font-weight:900;
    box-shadow:0 2px 8px rgba(0,0,0,.35);
  }
  .hud{
    background:var(--panel); border-radius:14px; padding:14px; border:1px solid #1f2450;
    box-shadow:0 8px 24px rgba(0,0,0,.35);
  }
  .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .space{ height:10px }
  button{
    background:#24305d; color:#e8eeff; border:1px solid #2e3b76; padding:9px 12px; border-radius:10px; font-weight:700;
    cursor:pointer; transition: transform .05s ease, background .18s ease;
  }
  button:hover{ background:#2b3a78 }
  button:active{ transform: translateY(1px) }
  .good{ background:#1f3f3a; border-color:#2b6a5d }
  .bad{ background:#472f39; border-color:#7a4056 }
  .muted{ background:#232840; color:#aab3d9 }
  .pill{ font-size:11px; padding:3px 8px; border-radius:999px; background:#22305e; border:1px solid #303f75; color:#a0b2ff }
  .status{ font-size:13px; color:var(--muted) }
  .log{
    max-height:220px; overflow:auto; background:#141833; border-radius:10px; padding:8px 10px; border:1px solid #21264a;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
    font-size:12px; line-height:1.35;
  }
  details{
    background:#141833; border-radius:10px; border:1px solid #21264a; padding:8px 10px;
  }
  details[open]{ box-shadow:0 4px 14px rgba(0,0,0,.25) }
  summary{ cursor:pointer; font-weight:700 }
  .legend{ display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:8px }
  .lg-item{ display:flex; gap:8px; align-items:center; background:#101431; padding:8px; border-radius:10px; border:1px solid #1d2450 }
  .tok{ width:34px; height:34px; border-radius:8px; display:grid; place-items:center; font-size:11px; font-weight:800; }
  .k{ background:#ef476f } .q{ background:#ffd166; color:#330 } .r{ background:#06d6a0; color:#033 } .b{ background:#118ab2 } .n{ background:#9b5de5 } .p{ background:#a8dadc; color:#033 }
  .promo{
    position:absolute; inset:0; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center;
  }
  .promo .card{
    background:#151a35; border:1px solid #28316a; border-radius:12px; padding:12px; width:min(560px, 92vw);
  }
  .promo h3{ margin:4px 0 10px; font-size:15px }
  .choices{ display:grid; grid-template-columns: repeat(4, 1fr); gap:8px; }
  .choice{ background:#1b2146; border:1px solid #2a3572; border-radius:10px; padding:10px; cursor:pointer; }
  .choice:hover{ background:#212a57; }
  .toast{
    position:fixed; left:50%; bottom:16px; transform:translateX(-50%);
    background:#1b2146; border:1px solid #2a3572; color:#dfe7ff; padding:8px 12px; border-radius:10px;
    display:none; gap:10px; align-items:center; z-index:9999;
  }
</style>
</head>
<body>
<header>
  <h1>Pokémon Chess — รุ่นเสถียร</h1>
  <div class="row">
    <button id="startBtn" class="good">เริ่มเกม</button>
    <button id="endBtn" class="bad" disabled>จบเกม (ยอมแพ้)</button>
    <button id="resetBtn" class="muted">รีเซ็ตกระดาน</button>
    <button id="flipBtn" class="muted">สลับมุมมอง</button>
  </div>
</header>

<div class="wrap">
  <div class="board" id="board">
    <div class="grid" id="grid"></div>
    <div class="promo" id="promo">
      <div class="card">
        <h3>โปรโมตพอน (เลือกวิวัฒนาการ)</h3>
        <div class="choices" id="promoChoices"></div>
        <div class="status" style="margin-top:6px">ธีม Eevee → Raichu/Flareon/Vaporeon/Espeon (เทียบ Q/R/B/N)</div>
      </div>
    </div>
  </div>
  <div class="hud">
    <div class="row" style="justify-content:space-between">
      <div class="row">
        <span class="pill" id="turnPill">สถานะ: ยังไม่เริ่ม</span>
        <span class="pill" id="checkPill" style="display:none; background:#512f3c; border-color:#7a3f56; color:#ffc2cc">เช็ค!</span>
        <span class="pill" id="evoPill" style="display:none;">ปลดล็อกสกิล</span>
      </div>
      <div class="row">
        <button id="useAbilityBtn" class="good" disabled>ใช้สกิล</button>
        <button id="cancelAbilityBtn" class="bad" disabled>ยกเลิก</button>
      </div>
    </div>
    <div class="space"></div>
    <div class="status" id="status">กติกาเหมือนหมากรุกมาตรฐาน + สกิลวิวัฒนาการเฉพาะตัว</div>
    <div class="space"></div>
    <h3 style="margin:6px 0">บันทึกการเดิน</h3>
    <div class="log" id="log"></div>
    <div class="space"></div>
    <details id="legendBox" open>
      <summary>ตารางความสามารถ (คลิกเพื่อพับ/ขยาย)</summary>
      <div class="legend">
        <div class="lg-item"><div class="tok k">K</div><div>King = Mewtwo — วิวัฒนาการเชิงคอสเมติกเมื่อเคยถูกเช็ค</div></div>
        <div class="lg-item"><div class="tok q">Q</div><div>Queen = Pikachu → Raichu — จับกิน 2 ครั้ง → Blink (ขยับ 1 ช่องหลังการกิน)</div></div>
        <div class="lg-item"><div class="tok r">R</div><div>Rook = Bulbasaur → Ivysaur — เดินครบ 3 ครั้ง → Charge (เดินแบบไนท์ได้ 1 เทิร์น)</div></div>
        <div class="lg-item"><div class="tok b">B</div><div>Bishop = Squirtle → Wartortle — ระยะรวมที่เดิน ≥ 12 ช่อง → Long Step (+1 ก้าวทแยงหลังเดิน)</div></div>
        <div class="lg-item"><div class="tok n">N</div><div>Knight = Charmander → Charmeleon — กินได้ 1 ครั้ง → Quick Attack (เดินอีกครั้งต่อเนื่อง)</div></div>
        <div class="lg-item"><div class="tok p">P</div><div>Pawn = Eevee — โปรโมตเป็น Q/R/B/N แบบธีม</div></div>
      </div>
    </details>
  </div>
</div>

<div class="toast" id="toast">
  <span id="toastText">ข้อความ</span>
  <button id="toastOk" class="good">ตกลง</button>
  <button id="toastCancel" class="muted">ปิด</button>
</div>

<script>
/* ---------------- Core Engine (improved) ---------------- */
const SIZE=8, WHITE='w', BLACK='b', EMPTY=null;
const DIRS={ n:[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]],
             k:[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]],
             r:[[1,0],[-1,0],[0,1],[0,-1]], b:[[1,1],[1,-1],[-1,1],[-1,-1]] };
DIRS.q=[...DIRS.r, ...DIRS.b];
const START_FEN="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";

let SID=1;
function makePiece(type,color){
  return { type, color, id:(color+type+(SID++)), meta:{
    moved:false, captures:0, steps:0, travel:0, evolved:false, abilityUsed:false, wasChecked:false
  }};
}
function inBounds(r,c){ return r>=0&&r<8&&c>=0&&c<8 }
function algebra(r,c){ return 'abcdefgh'[c]+(8-r) }
function parseAlg(s){ return [8-parseInt(s[1]), 'abcdefgh'.indexOf(s[0])] }
function clone(o){ return structuredClone(o) }

function fenToState(fen){
  const [pp, active, castling, ep, half, full] = fen.split(' ');
  const rows=pp.split('/'); const board=Array.from({length:8},()=>Array(8).fill(EMPTY));
  rows.forEach((row, rIdx)=>{
    let c=0;
    for(const ch of row){
      if(/\d/.test(ch)){ c+=parseInt(ch); } else {
        const color = ch===ch.toUpperCase()?WHITE:BLACK;
        const type = ch.toLowerCase();
        board[rIdx][c++]=makePiece(type,color);
      }
    }
  });
  return {board, active:(active==='w'?WHITE:BLACK), castling:(castling==='-'?'':castling), ep:(ep==='-'?null:parseAlg(ep)),
          halfmove:parseInt(half||'0'), fullmove:parseInt(full||'1'),
          lastMove:null, flipped:false, selected:null, legalCache:null, abilityMode:null, history:[],
          phase:'idle', result:null};
}

function squareAttacked(state,r,c,byColor){
  const b=state.board;
  for(const [dr,dc] of DIRS.n){
    const rr=r+dr, cc=c+dc; if(inBounds(rr,cc)){ const p=b[rr][cc]; if(p&&p.color===byColor&&p.type==='n') return true; }
  }
  for(const [dr,dc] of DIRS.k){
    const rr=r+dr, cc=c+dc; if(inBounds(rr,cc)){ const p=b[rr][cc]; if(p&&p.color===byColor&&p.type==='k') return true; }
  }
  for(const [dr,dc] of DIRS.r){
    let rr=r+dr,cc=c+dc; while(inBounds(rr,cc)){ const p=b[rr][cc]; if(!p){ rr+=dr; cc+=dc; continue; }
      if(p.color===byColor&&(p.type==='r'||p.type==='q')) return true; break; }
  }
  for(const [dr,dc] of DIRS.b){
    let rr=r+dr,cc=c+dc; while(inBounds(rr,cc)){ const p=b[rr][cc]; if(!p){ rr+=dr; cc+=dc; continue; }
      if(p.color===byColor&&(p.type==='b'||p.type==='q')) return true; break; }
  }
  const pawnDir=byColor===WHITE?-1:1;
  for(const dc of [-1,1]){
    const rr=r+pawnDir, cc=c+dc; if(inBounds(rr,cc)){ const p=b[rr][cc]; if(p&&p.color===byColor&&p.type==='p') return true; }
  }
  return false;
}
function findKing(state,color){ for(let r=0;r<8;r++) for(let c=0;c<8;c++){ const p=state.board[r][c]; if(p&&p.type==='k'&&p.color===color) return [r,c]; } return null; }
function inCheck(state,color){ const k=findKing(state,color); if(!k) return false; return squareAttacked(state,k[0],k[1],color===WHITE?BLACK:WHITE) }

function genPseudo(state,r,c){
  const b=state.board; const p=b[r][c]; if(!p) return [];
  const moves=[]; const forward=p.color===WHITE?-1:1;
  function push(rr,cc,flags={}){
    if(!inBounds(rr,cc)) return; const t=b[rr][cc];
    if(!t){ if(!flags.captureOnly) moves.push({from:[r,c],to:[rr,cc],piece:p,flags,capture:null}); }
    else if(t.color!==p.color){ moves.push({from:[r,c],to:[rr,cc],piece:p,flags:{...flags,capture:true},capture:t}); }
  }
  if(p.type==='p'){
    const r1=r+forward; if(inBounds(r1,c)&&!b[r1][c]){ push(r1,c,{});
      const start=(p.color===WHITE?6:1); if(r===start){ const r2=r+2*forward; if(!b[r2][c]) moves.push({from:[r,c],to:[r2,c],piece:p,flags:{double:true},capture:null}); } }
    for(const dc of [-1,1]){ const cc=c+dc, rr=r+forward; if(inBounds(rr,cc)){ const t=b[rr][cc]; if(t&&t.color!==p.color) moves.push({from:[r,c],to:[rr,cc],piece:p,flags:{capture:true},capture:t}); } }
    if(state.ep){ const [er,ec]=state.ep; if(er===r+forward && Math.abs(ec-c)===1){ moves.push({from:[r,c],to:[er,ec],piece:p,flags:{enpassant:true,capture:true},capture:b[r][ec]}); } }
  } else if(p.type==='n'){ for(const [dr,dc] of DIRS.n) push(r+dr,c+dc,{});
  } else if(p.type==='k'){ for(const [dr,dc] of DIRS.k) push(r+dr,c+dc,{});
    const rights=state.castling||'';
    if(!p.meta.moved && !inCheck(state,p.color)){
      if((p.color===WHITE&&rights.includes('K'))||(p.color===BLACK&&rights.includes('k'))){
        const rr=r, c1=c+1, c2=c+2; if(!b[rr][c1]&&!b[rr][c2]&&!squareAttacked(state,rr,c1,p.color===WHITE?BLACK:WHITE)&&!squareAttacked(state,rr,c2,p.color===WHITE?BLACK:WHITE))
          moves.push({from:[r,c],to:[rr,c2],piece:p,flags:{castle:'kingside'}});
      }
      if((p.color===WHITE&&rights.includes('Q'))||(p.color===BLACK&&rights.includes('q'))){
        const rr=r, c1=c-1,c2=c-2,c3=c-3; if(!b[rr][c1]&&!b[rr][c2]&&!b[rr][c3]&&!squareAttacked(state,rr,c1,p.color===WHITE?BLACK:WHITE)&&!squareAttacked(state,rr,c2,p.color===WHITE?BLACK:WHITE))
          moves.push({from:[r,c],to:[rr,c2],piece:p,flags:{castle:'queenside'}});
      }
    }
  } else {
    const lines = p.type==='r'?DIRS.r : p.type==='b'?DIRS.b : DIRS.q;
    for(const [dr,dc] of lines){ let rr=r+dr, cc=c+dc;
      while(inBounds(rr,cc)){ const t=b[rr][cc];
        if(!t) moves.push({from:[r,c],to:[rr,cc],piece:p,flags:{},capture:null});
        else { if(t.color!==p.color) moves.push({from:[r,c],to:[rr,cc],piece:p,flags:{capture:true},capture:t}); break; }
        rr+=dr; cc+=dc;
      }
    }
  }
  return moves;
}
function makeMove(state,move){
  let s=clone(state); const b=s.board; const [fr,fc]=move.from, [tr,tc]=move.to; const piece=b[fr][fc];
  s.ep=null; b[fr][fc]=EMPTY;
  if(move.flags?.enpassant){ const dir=piece.color===WHITE?1:-1; b[tr+dir][tc]=EMPTY; }
  if(move.flags?.castle){
    if(move.flags.castle==='kingside'){ b[fr][5]=b[fr][7]; if(b[fr][5]) b[fr][5].meta.moved=true; b[fr][7]=EMPTY; }
    else{ b[fr][3]=b[fr][0]; if(b[fr][3]) b[fr][3].meta.moved=true; b[fr][0]=EMPTY; }
  }
  const target=b[tr][tc]; if(target) s.capture=target;
  b[tr][tc]=piece; piece.meta.moved=true; piece.meta.steps+=1; piece.meta.travel += Math.abs(fr-tr)+Math.abs(fc-tc);
  if(s.capture) piece.meta.captures+=1;
  if(piece.type==='p' && move.flags?.double){ s.ep=[(fr+tr)/2, fc]; }
  function revoke(ch){ s.castling=(s.castling||'').replace(ch,''); if(s.castling==='') s.castling=''; }
  if(piece.type==='k'){ if(piece.color===WHITE){revoke('K');revoke('Q');} else {revoke('k');revoke('q');} }
  if(piece.type==='r'){
    if(piece.color===WHITE&&fr===7&&fc===0) revoke('Q'); if(piece.color===WHITE&&fr===7&&fc===7) revoke('K');
    if(piece.color===BLACK&&fr===0&&fc===0) revoke('q'); if(piece.color===BLACK&&fr===0&&fc===7) revoke('k');
  }
  if(s.capture && s.capture.type==='r'){
    if(s.capture.color===WHITE && tr===7 && tc===0) revoke('Q');
    if(s.capture.color===WHITE && tr===7 && tc===7) revoke('K');
    if(s.capture.color===BLACK && tr===0 && tc===0) revoke('q');
    if(s.capture.color===BLACK && tr===0 && tc===7) revoke('k');
  }
  s.halfmove = (piece.type==='p'||s.capture)?0:((s.halfmove||0)+1);
  if(piece.color===BLACK) s.fullmove=(s.fullmove||1)+1;
  s.active = (piece.color===WHITE?BLACK:WHITE);
  s.lastMove=move; s.legalCache=null; s.history=s.history||[]; s.history.push({move, fen:stateToFen(s)});
  return s;
}
function genLegal(state,r,c){
  const p=state.board[r][c]; if(!p || p.color!==state.active) return [];
  const pseudo=genPseudo(state,r,c); const out=[];
  for(const m of pseudo){ const s2=makeMove(state,m); if(!inCheck(s2,p.color)) out.push(m); }
  return out;
}
function anyLegal(state,color){
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){ const p=state.board[r][c]; if(p&&p.color===color){ const ms=genLegal(state,r,c); if(ms.length) return true; } }
  return false;
}
function stateToFen(state){
  const b=state.board; let rows=[];
  for(let r=0;r<8;r++){ let row='', empty=0;
    for(let c=0;c<8;c++){ const p=b[r][c]; if(!p){ empty++; } else { if(empty){ row+=empty; empty=0; } const ch=p.type.toUpperCase(); row+=(p.color===WHITE?ch:ch.toLowerCase()); } }
    if(empty) row+=empty; rows.push(row);
  }
  const cast=state.castling||'-'; const ep=state.ep?algebra(state.ep[0],state.ep[1]):'-';
  return rows.join('/')+' '+state.active+' '+cast+' '+ep+' '+(state.halfmove||0)+' '+(state.fullmove||1);
}

/* -------------- Evolution & Abilities -------------- */
function checkEvolution(piece){
  if(piece.meta.evolved) return;
  if(piece.type==='n' && piece.meta.captures>=1) piece.meta.evolved=true;
  if(piece.type==='r' && piece.meta.steps>=3) piece.meta.evolved=true;
  if(piece.type==='b' && piece.meta.travel>=12) piece.meta.evolved=true;
  if(piece.type==='q' && piece.meta.captures>=2) piece.meta.evolved=true;
  if(piece.type==='k' && piece.meta.wasChecked) piece.meta.evolved=true;
}
function canUseAbility(state,piece){
  if(!piece.meta.evolved || piece.meta.abilityUsed) return null;
  if(state.phase!=='playing') return null;
  if(!state.selected) return null;
  const [r,c]=state.selected;
  if(state.board[r][c]?.id!==piece.id) return null;
  if(piece.color!==state.active) return null;
  if(piece.type==='n') return {kind:'quick'};
  if(piece.type==='r') return {kind:'charge'};
  if(piece.type==='b') return {kind:'longstep'};
  if(piece.type==='q') return {kind:'blink'};
  return null;
}
function abilityName(kind){
  return {quick:'Quick Attack (เดินต่ออีก 1 ครั้ง)',
          charge:'Charge (เดินแบบ Knight 1 เทิร์น)',
          longstep:'Long Step (+1 ทแยงหลังเดิน)',
          blink:'Blink (ขยับ 1 ช่องหลังการกิน)'}[kind] || kind;
}

/* -------------- UI -------------- */
const gridEl=document.getElementById('grid');
const statusEl=document.getElementById('status');
const turnPill=document.getElementById('turnPill');
const checkPill=document.getElementById('checkPill');
const evoPill=document.getElementById('evoPill');
const logEl=document.getElementById('log');
const promoOverlay=document.getElementById('promo');
const promoChoices=document.getElementById('promoChoices');
const startBtn=document.getElementById('startBtn');
const endBtn=document.getElementById('endBtn');
const resetBtn=document.getElementById('resetBtn');
const flipBtn=document.getElementById('flipBtn');
const useAbilityBtn=document.getElementById('useAbilityBtn');
const cancelAbilityBtn=document.getElementById('cancelAbilityBtn');
const toast=document.getElementById('toast');
const toastText=document.getElementById('toastText');
const toastOk=document.getElementById('toastOk');
const toastCancel=document.getElementById('toastCancel');

let S=fenToState(START_FEN); S.castling='KQkq';

function newGame(){ S=fenToState(START_FEN); S.castling='KQkq'; S.phase='idle'; S.history=[]; render(); logEl.textContent=''; log('รีเซ็ตกระดาน'); }
function startGame(){ if(S.phase==='playing') return; S.phase='playing'; render(); log('เริ่มเกม'); }
function endGame(resignBy=null){
  if(S.phase!=='playing') return;
  S.phase='ended';
  if(resignBy){
    S.result = (resignBy===WHITE? 'ดำชนะ (ขาวยอมแพ้)':'ขาวชนะ (ดำยอมแพ้)');
  }else{
    S.result = statusEl.textContent;
  }
  render(); toastShow(S.result);
}
function flip(){ S.flipped=!S.flipped; render(); }

startBtn.addEventListener('click', ()=>{ startGame(); });
endBtn.addEventListener('click', ()=>{ endGame(S.active); });
resetBtn.addEventListener('click', newGame);
flipBtn.addEventListener('click', flip);

function toastShow(txt){ toastText.textContent=txt; toast.style.display='flex'; }
function toastHide(){ toast.style.display='none'; }
toastOk.addEventListener('click', toastHide);
toastCancel.addEventListener('click', toastHide);

/* Piece Image (SVG data URI) */
function pieceTheme(piece){
  const colors = { k:'#ef476f', q:'#ffd166', r:'#06d6a0', b:'#118ab2', n:'#9b5de5', p:'#a8dadc' };
  const nameMap = {
    k:'Mewtwo', q:(piece.meta?.evolved?'Raichu':'Pikachu'),
    r:(piece.meta?.evolved?'Ivysaur':'Bulbasaur'),
    b:(piece.meta?.evolved?'Wartortle':'Squirtle'),
    n:(piece.meta?.evolved?'Charmeleon':'Charmander'),
    p:'Eevee'
  };
  const bg=colors[piece.type]||'#888';
  const nm=nameMap[piece.type]||piece.type.toUpperCase();
  const side = piece.color===WHITE?'#3e6cf6':'#a23bd9';
  const label = piece.type.toUpperCase();
  const svg = encodeURIComponent(`
  <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'>
    <defs>
      <linearGradient id='g' x1='0' y1='0' x2='0' y2='1'>
        <stop offset='0' stop-color='${bg}' stop-opacity='0.95'/>
        <stop offset='1' stop-color='${bg}' stop-opacity='0.75'/>
      </linearGradient>
    </defs>
    <rect x='5' y='5' width='90' height='90' rx='14' ry='14' fill='url(#g)' stroke='${side}' stroke-width='0' />
    <g fill='rgba(0,0,0,0.18)'>
      <circle cx='58' cy='36' r='16'/>
      <rect x='24' y='48' width='52' height='28' rx='12'/>
    </g>
    <text x='50' y='54' font-size='34' font-family='Verdana,Arial,sans-serif' text-anchor='middle' fill='#1b2045'>${label}</text>
    <text x='50' y='86' font-size='13' font-family='Verdana,Arial,sans-serif' text-anchor='middle' fill='#0d1026'>${nm}</text>
  </svg>`);
  return `data:image/svg+xml;charset=utf-8,${svg}`;
}

function render(){
  gridEl.innerHTML='';
  const rows=[0,1,2,3,4,5,6,7], cols=[0,1,2,3,4,5,6,7];
  if(S.flipped){ rows.reverse(); cols.reverse(); }
  for(const r of rows){
    for(const c of cols){
      const sq=document.createElement('div');
      sq.className='sq '+(((r+c)%2===0)?'a':'b') + (S.selected && S.selected[0]===r && S.selected[1]===c?' sel':'');
      sq.dataset.r=r; sq.dataset.c=c;
      const p=S.board[r][c];
      if(p){
        const wrap=document.createElement('div'); wrap.className='piece '+(p.color==='w'?'w':'b');
        const img=document.createElement('img'); img.className='piece-img'; img.alt=p.type; img.src=pieceTheme(p);
        wrap.appendChild(img); sq.appendChild(wrap);
        if(p.meta.evolved && !p.meta.abilityUsed && ['n','r','b','q'].includes(p.type)){
          const badge=document.createElement('div'); badge.className='badge'; badge.textContent='★'; sq.appendChild(badge);
        }
      }
      gridEl.appendChild(sq);
    }
  }
  if(S.phase==='playing' && S.selected){
    const legals=genLegal(S,S.selected[0],S.selected[1]);
    for(const mv of legals){
      const [rr,cc]=mv.to;
      const visR = S.flipped? 7-rr : rr;
      const visC = S.flipped? 7-cc : cc;
      const idx = rows.indexOf(visR)*8 + cols.indexOf(visC);
      const el = gridEl.children[idx];
      el.classList.add(S.board[rr][cc]? 'cap':'mv');
    }
  }

  const turnName = S.active==='w'?'ขาว':'ดำ';
  const inCk = inCheck(S, S.active);
  turnPill.textContent = (S.phase==='idle'?'สถานะ: ยังไม่เริ่ม': S.phase==='ended'? 'จบเกม' : 'ตา: '+turnName);
  checkPill.style.display = (S.phase==='playing' && inCk)? 'inline-flex':'none';

  startBtn.disabled = (S.phase==='playing');
  endBtn.disabled = (S.phase!=='playing');
  useAbilityBtn.disabled = true;
  cancelAbilityBtn.disabled = !S.abilityMode;

  if(S.phase==='playing' && S.selected){
    const p=S.board[S.selected[0]][S.selected[1]];
    const ab=p? canUseAbility(S,p): null;
    evoPill.style.display = ab? 'inline-flex':'none';
    useAbilityBtn.disabled = !ab;
  }else{
    evoPill.style.display='none';
  }

  if(S.phase==='idle'){ statusEl.textContent='กด “เริ่มเกม” เพื่อเล่น'; }
  else if(S.phase==='playing'){
    let desc = inCk? `เช็คฝ่าย ${turnName}` : `ถึงตา ${turnName}`;
    if(!anyLegal(S, S.active)){ desc = inCk? 'เช็คเมท!' : 'เสมอ (Stalemate)'; }
    statusEl.textContent = desc;
  }else{
    statusEl.textContent = S.result || 'จบเกม';
  }
}

gridEl.addEventListener('click', onClickSquare);
function onClickSquare(e){
  const sq=e.target.closest('.sq'); if(!sq) return;
  if(S.phase!=='playing'){ toastShow('ยังไม่เริ่มเกม'); return; }
  const r=parseInt(sq.dataset.r), c=parseInt(sq.dataset.c);
  const p=S.board[r][c];
  if(S.abilityMode){ return handleAbilityClick(r,c); }
  if(S.selected){
    const from=S.selected; const piece=S.board[from[0]][from[1]];
    const moves=genLegal(S,from[0],from[1]);
    const chosen=moves.find(m=>m.to[0]===r && m.to[1]===c);
    if(chosen){
      if(piece.type==='p' && (r===0||r===7)){ showPromotion(from,[r,c],piece); return; }
      doMove(chosen);
      postMoveAbilityPrompt(chosen);
      return;
    } else {
      if(p && p.color===S.active){ S.selected=[r,c]; render(); return; }
      S.selected=null; render(); return;
    }
  } else {
    if(p && p.color===S.active){ S.selected=[r,c]; render(); }
  }
}

function doMove(move){
  const before=clone(S); S=makeMove(S,move);
  if(inCheck(before, before.active)){ const kPos=findKing(S, before.active); if(kPos){ const k=S.board[kPos[0]][kPos[1]]; if(k) k.meta.wasChecked=true; } }
  const [tr,tc]=move.to; const moved=S.board[tr][tc]; if(moved){ checkEvolution(moved); if(S.capture) checkEvolution(moved); }
  logMove(move); S.selected=null; render();
  if(S.phase==='playing' && !anyLegal(S, S.active)){
    endGame();
  }
}
function log(t){ logEl.textContent += t + "\n"; logEl.scrollTop = logEl.scrollHeight; }
function logMove(m){
  const from=algebra(m.from[0],m.from[1]), to=algebra(m.to[0],m.to[1]);
  const p=m.piece; const cap=m.flags?.capture?'x':''; const name=({k:'K',q:'Q',r:'R',b:'B',n:'N',p:''})[p.type];
  const mvNum=((S.active===WHITE)?(S.fullmove-1):S.fullmove);
  log(mvNum+". "+(p.color===BLACK?'.. ':'')+name+from+cap+to+(m.flags?.castle?' (O-O'+(m.flags.castle==='queenside'?'-O':'')+')':''));
}

/* Promotion */
function showPromotion(from,to,pawn){
  promoOverlay.style.display='flex'; promoChoices.innerHTML='';
  const options=[ {type:'q',label:'Raichu (Queen)'}, {type:'r',label:'Flareon (Rook)'},
                  {type:'b',label:'Vaporeon (Bishop)'}, {type:'n',label:'Espeon (Knight)'} ];
  for(const opt of options){
    const el=document.createElement('div'); el.className='choice';
    el.innerHTML=`<div class="row"><div class="tok ${opt.type}">${opt.type.toUpperCase()}</div><div>${opt.label}</div></div>`;
    el.addEventListener('click', ()=>{
      promoOverlay.style.display='none';
      const move=genLegal(S,from[0],from[1]).find(m=>m.to[0]===to[0]&&m.to[1]===to[1]); if(!move) return;
      doMove(move);
      const [r,c]=to; const np=S.board[r][c]; np.type=opt.type; np.meta.evolved=true; render(); log('โปรโมตเป็น '+opt.label);
    });
    promoChoices.appendChild(el);
  }
}

/* Abilities */
useAbilityBtn.addEventListener('click', ()=>{
  if(!S.selected) return;
  const p=S.board[S.selected[0]][S.selected[1]];
  const ab=p?canUseAbility(S,p):null; if(!ab) return;
  S.abilityMode={pieceId:p.id,kind:ab.kind,step:0,origin:S.selected};
  toastShow('โหมดสกิล: '+abilityName(ab.kind)+' — เลือกช่องปลายทาง');
});
cancelAbilityBtn.addEventListener('click', ()=>{ S.abilityMode=null; render(); });

function handleAbilityClick(r,c){
  const mode=S.abilityMode; if(!mode) return;
  const [sr,sc]=mode.origin; const piece=S.board[sr][sc]; if(!piece||piece.id!==mode.pieceId){ S.abilityMode=null; render(); return; }
  if(mode.kind==='charge'){
    const targets=[]; for(const [dr,dc] of DIRS.n){ const rr=sr+dr,cc=sc+dc; if(inBounds(rr,cc)){ const t=S.board[rr][cc]; if(!t||t.color!==piece.color) targets.push([rr,cc]); } }
    if(targets.some(([rr,cc])=>rr===r&&cc===c)){
      const mv={from:[sr,sc],to:[r,c],piece,capture:S.board[r][c]||null,flags:{}};
      const S2=makeMove(S,mv); if(!inCheck(S2,piece.color)){ S=S2; piece.meta.abilityUsed=true; S.selected=null; S.abilityMode=null; render(); log('ใช้สกิล Charge (Rook)'); }
    }
    return;
  }
  if(mode.kind==='quick'){
    const targets=DIRS.n.map(([dr,dc])=>[sr+dr,sc+dc]).filter(([rr,cc])=>inBounds(rr,cc)&&(!S.board[rr][cc]||S.board[rr][cc].color!==piece.color));
    if(targets.some(([rr,cc])=>rr===r&&cc===c)){
      const mv={from:[sr,sc],to:[r,c],piece,capture:S.board[r][c]||null,flags:{}};
      const S2=makeMove(S,mv); if(!inCheck(S2,piece.color)){ S=S2; piece.meta.abilityUsed=true; S.selected=null; S.abilityMode=null; render(); log('ใช้สกิล Quick Attack (Knight)'); }
    }
    return;
  }
  if(mode.kind==='longstep'){
    if(Math.abs(r-sr)===1 && Math.abs(c-sc)===1 && !S.board[r][c]){
      const mv={from:[sr,sc],to:[r,c],piece,flags:{},capture:null};
      const S2=makeMove(S,mv); if(!inCheck(S2,piece.color)){ S=S2; piece.meta.abilityUsed=true; S.selected=null; S.abilityMode=null; render(); log('ใช้สกิล Long Step (Bishop)'); }
    }
    return;
  }
  if(mode.kind==='blink'){
    if(Math.abs(r-sr)<=1 && Math.abs(c-sc)<=1 && (Math.abs(r-sr)+Math.abs(c-sc)>0) && !S.board[r][c]){
      const mv={from:[sr,sc],to:[r,c],piece,flags:{},capture:null};
      const S2=makeMove(S,mv); if(!inCheck(S2,piece.color)){ S=S2; piece.meta.abilityUsed=true; S.selected=null; S.abilityMode=null; render(); log('ใช้สกิล Blink (Queen)'); }
    }
    return;
  }
}

function postMoveAbilityPrompt(move){
  const piece=S.board[move.to[0]][move.to[1]]; if(!piece) return;
  if(piece.type==='q' && move.flags?.capture && piece.meta.evolved && !piece.meta.abilityUsed){
    S.selected=[move.to[0],move.to[1]]; S.abilityMode={pieceId:piece.id,kind:'blink',origin:[move.to[0],move.to[1]],step:1};
    toastShow('Queen ใช้ Blink ได้: เลือก 1 ช่อง (ไม่บังคับ)');
    render(); return;
  }
  if(piece.type==='b' && piece.meta.evolved && !piece.meta.abilityUsed){
    S.selected=[move.to[0],move.to[1]]; S.abilityMode={pieceId:piece.id,kind:'longstep',origin:[move.to[0],move.to[1]],step:1};
    toastShow('Bishop ใช้ Long Step ได้: เลือก 1 ช่องทแยง (ไม่บังคับ)');
    render(); return;
  }
  if(piece.type==='n' && piece.meta.evolved && !piece.meta.abilityUsed){
    S.selected=[move.to[0],move.to[1]]; S.abilityMode={pieceId:piece.id,kind:'quick',origin:[move.to[0],move.to[1]],step:1};
    toastShow('Knight ใช้ Quick Attack ได้: เลือกตำแหน่งที่สอง (ไม่บังคับ)');
    render(); return;
  }
}

/* Init */
function setup(){ newGame(); }
setup();
</script>
</body>
</html>
